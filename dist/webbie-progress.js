(()=>{"use strict";const e={render(e){return`\n        ${this.css(e.css)}\n        ${this.html(e.html)}\n    `},html(e){return`\n        <svg id="container" width="${e.size}" height="${e.size}" viewBox="0 0 100 100">\n        <defs>\n        <clipPath id="clipper">\n        <path\n        d="${this.generatePolygon(e.vertices,e.radius,e.frameWidth??e.strokeWidth)}" />\n        </clipPath>\n        </defs>\n        \n        ${e.imgUrl?`<image id="fillimg" href="${e.imgUrl}" x="0" y="0" width="100%" height="100%"\n        preserveAspectRatio="xMinYMin slice"\n        clip-path="url(#clipper)" />`:""}\n\n        <path id="framepath"\n        stroke-width="${e.frameWidth??e.strokeWidth}"\n        stroke-linejoin="round"\n        fill="transparent"\n        d="${this.generatePolygon(e.vertices,e.radius)}" />\n\n        <path id="strokepath"\n        stroke-width="${e.strokeWidth}"\n        stroke-linecap="round"\n        stroke-linejoin="round"\n        fill="transparent"\n        d="${this.generatePolygon(e.vertices,e.radius)}"\n        pathLength="100"\n        >\n        </path>\n        \n        <text\n        x="50" y="50"\n        text-anchor="middle"\n        alignment-baseline="middle"\n        dominant-baseline="middle">${e.text??""}</text>\n        \n        </svg>\n    `},css:e=>`\n    <style>\n        #container {\n        }\n        #strokepath {\n            transform: rotate(${e.rotate}deg);\n            transform-origin: 50% 50%;\n            stroke-dashoffset: ${10*e.rotate/36};\n            stroke-dasharray: ${e.percent} ${100-e.percent};\n            filter: drop-shadow(0 0 1px ${e.strokeShadow??"transparent"});\n            stroke: ${e.strokeColor??"#3969ef"};\n            transition: stroke-dasharray 1s;\n            animation: snake ${e.strokeSpeed??"0s"} linear ${e.strokeReverse?"reverse":""} infinite, rotate ${!e.imgUrl&&e.frameSpeed?e.frameSpeed:"0s"} linear ${e.frameReverse?"reverse":""} infinite;\n            ${e.strokeStyle??""}\n        }\n        #framepath {\n            transform: rotate(${e.rotate}deg);\n            transform-origin: 50% 50%;\n            stroke: ${e.frameColor??"#aaaaaa"};\n            fill: ${!e.imgUrl&&e.fillColor?e.fillColor:"transparent"};\n            animation: rotate ${!e.imgUrl&&e.frameSpeed?e.frameSpeed:"0s"} linear ${e.frameReverse?"reverse":""} infinite;\n            ${e.frameStyle??""}\n        }\n        #clipper {\n          transform: rotate(${e.rotate}deg);\n          transform-origin: 50% 50%;\n        }\n        text {${e.textStyle}}\n          \n        @keyframes snake {\n            0% {\n                stroke-dashoffset: ${10*e.rotate/36};\n            }\n            100% {\n                stroke-dashoffset: ${10*e.rotate/36-100};\n            }\n        }\n\n        @keyframes rotate {\n            0% {\n                transform: rotate(0deg);\n            }\n            100% {\n                transform: rotate(360deg);\n            }\n        }\n    </style>\n    `,generatePolygon(e,t,r){let n=50-t;r&&(n+=1*r/2);const s=50-n;let i=`M 50 ${n} `;if(e<3)return i+=`A ${s} ${s} 0 0 1 50 ${50+s}`,i+=`A ${s} ${s} 0 0 1 50 ${n}`,i;let a=360/e;for(let t=1;t<e;t++){const e=a*t*Math.PI/180;i+=`L ${50+s*Math.sin(e)} ${50-s*Math.cos(e)} `}return i+="Z",i}};class t extends HTMLElement{constructor(){super(),this.attachShadow({mode:"open"}),this.render()}static get observedAttributes(){return["percent","vertices","rotate","size","text","text-style","image","radius","stroke-width","frame-width","stroke-color","frame-color","fill-color","stroke-shadow","stroke-anim-speed","frame-anim-speed","stroke-anim-reverse","frame-anim-reverse","stroke-style","frame-style"]}attributeChangedCallback(e,t,r){"percent"===e?this.shadowRoot.getElementById("strokepath").style.strokeDasharray=`${r} ${100-r}`:this.render()}render(){const t=Number(this.getAttribute("vertices")),r=Number(this.getAttribute("rotate")),n=Number(this.getAttribute("percent")),s=this.getAttribute("size"),i=this.getAttribute("text"),a=this.getAttribute("text-style"),o=this.getAttribute("image"),l=Number(this.getAttribute("radius")),h=Number(this.getAttribute("stroke-width")),m=Number(this.getAttribute("frame-width")),d=this.getAttribute("stroke-color"),f=this.getAttribute("frame-color"),g=this.getAttribute("fill-color"),u=this.getAttribute("stroke-shadow"),p=this.getAttribute("stroke-anim-speed"),c=this.getAttribute("frame-anim-speed"),k=null!==this.getAttribute("stroke-anim-reverse"),$=null!==this.getAttribute("frame-anim-reverse"),b=this.getAttribute("stroke-style"),y=this.getAttribute("frame-style");this.shadowRoot.innerHTML=e.render({html:{size:s??"100px",strokeWidth:h?this.numerify(h,50):4,frameWidth:m?this.numerify(m,50):null,vertices:t?this.numerify(t.toFixed(0),20):0,text:i,imgUrl:o,radius:l?this.numerify(l,50):47},css:{rotate:r?this.numerify(r,360):0,percent:n?this.numerify(n,100):100,textStyle:a,strokeColor:d,frameColor:f,fillColor:g,strokeShadow:u,imgUrl:o,strokeSpeed:p,frameSpeed:c,strokeReverse:k,frameReverse:$,strokeStyle:b,frameStyle:y}})}numerify(e,t){return Math.max(Math.min(e,t),0)}}customElements.get("webbie-progress")||customElements.define("webbie-progress",t)})();